#Setting mean (m) and standard deviation (sd)

m ~ dnUnif(0,25)
sd ~ dnUnif(0,4)
m
sd

#Drawing a value from a normal dist on a stochastic node
z ~ dnNormal(m,sd)
z

for (i in 1:10){
    obs[i] ~ dnNormal(m, sd)
}
obs


obs = [23.80207, 23.77513, 23.75037, 23.71122, 23.68676, 23.71109, 23.71073, 23.68241, 23.66532, 23.65548]
for (i in 1:obs.size()){
    obsNodes[i] ~ dnNormal(23.48396, 2.65924)
    obsNodes[i].clamp(obs[i])
}

##Using this statement to specify our model, which really is just specifying a place for our chain to start
myModel = model(sd)

#We use this statement to decide which moves should be made in order to keep track of our chain.
moves[1] = mvSlide(m,delta=0.01,weight=1)

# If there were other parameters to infer, we could add additional moves here.

monitors[1] = mnScreen(printgen=100,m)

# If we were running this analysis from the command line, we could also add a monitor that prints to file
# However, this doesn't seem to work from inside a Jupyter notebook
monitors[2] = mnModel(filename="Teddy_week9_NormalDist_MCMC_NewPriors.log",printgen=1000, sep = TAB)

#Creating my MCMC
myMCMC = mcmc(myModel, moves, monitors)

#We will run our chain for 10000 generations
myMCMC.run(10000)
